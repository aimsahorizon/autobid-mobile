â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            AUTOBID MOBILE - NEXT IMPLEMENTATION STEPS                    â•‘
â•‘                    Continue from Browse Module                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… COMPLETED SO FAR
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ“ Database Schema (12 tables, RLS, Storage)
2. âœ“ Auth Module (Supabase + Google Sign-In)
3. âœ“ Profile Module (Complete Supabase integration)
4. âœ“ Browse Module - Started:
   - auction_supabase_datasource.dart created
   - Models already have JSON converters

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ STEP-BY-STEP: COMPLETE BROWSE MODULE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

STEP 1: Create Bid Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/browse/data/datasources/bid_supabase_datasource.dart

```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class BidSupabaseDataSource {
  final SupabaseClient _supabase;

  BidSupabaseDataSource(this._supabase);

  /// Place a bid on an auction
  Future<void> placeBid({
    required String vehicleId,
    required String bidderId,
    required double amount,
    bool isAutoBid = false,
    double? maxAutoBid,
  }) async {
    try {
      await _supabase.from('bids').insert({
        'vehicle_id': vehicleId,
        'bidder_id': bidderId,
        'amount': amount,
        'is_auto_bid': isAutoBid,
        'max_auto_bid': maxAutoBid,
        'status': 'active',
      });
    } on PostgrestException catch (e) {
      throw Exception('Failed to place bid: ${e.message}');
    }
  }

  /// Get bid history for an auction
  Future<List<Map<String, dynamic>>> getBidHistory(String vehicleId) async {
    try {
      final response = await _supabase
          .from('bids')
          .select('*, user_profiles(username, profile_photo_url)')
          .eq('vehicle_id', vehicleId)
          .order('created_at', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } on PostgrestException catch (e) {
      throw Exception('Failed to get bid history: ${e.message}');
    }
  }

  /// Get user's bids
  Future<List<Map<String, dynamic>>> getUserBids(String userId) async {
    try {
      final response = await _supabase
          .from('bids')
          .select('*, vehicles(id, brand, model, year, main_image_url, status, end_time)')
          .eq('bidder_id', userId)
          .order('created_at', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } on PostgrestException catch (e) {
      throw Exception('Failed to get user bids: ${e.message}');
    }
  }

  /// Check if user has deposited for auction
  Future<bool> hasDeposit(String userId, String vehicleId) async {
    try {
      final response = await _supabase
          .from('deposits')
          .select('id')
          .eq('user_id', userId)
          .eq('vehicle_id', vehicleId)
          .eq('status', 'confirmed')
          .maybeSingle();

      return response != null;
    } on PostgrestException catch (e) {
      throw Exception('Failed to check deposit: ${e.message}');
    }
  }

  /// Submit deposit for auction
  Future<void> submitDeposit({
    required String userId,
    required String vehicleId,
    required double amount,
    String? paymentReference,
  }) async {
    try {
      await _supabase.from('deposits').insert({
        'user_id': userId,
        'vehicle_id': vehicleId,
        'amount': amount,
        'status': 'pending',
        'payment_reference': paymentReference,
      });
    } on PostgrestException catch (e) {
      if (e.code == '23505') {
        throw Exception('Deposit already submitted for this auction');
      }
      throw Exception('Failed to submit deposit: ${e.message}');
    }
  }
}
```


STEP 2: Create Q&A Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/browse/data/datasources/qa_supabase_datasource.dart

```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class QASupabaseDataSource {
  final SupabaseClient _supabase;

  QASupabaseDataSource(this._supabase);

  /// Get Q&A for an auction
  Future<List<Map<String, dynamic>>> getQA(String vehicleId) async {
    try {
      final response = await _supabase
          .from('qa_entries')
          .select('*, user_profiles!asker_id(username, profile_photo_url)')
          .eq('vehicle_id', vehicleId)
          .eq('is_public', true)
          .order('created_at', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } on PostgrestException catch (e) {
      throw Exception('Failed to get Q&A: ${e.message}');
    }
  }

  /// Ask a question
  Future<void> askQuestion({
    required String vehicleId,
    required String askerId,
    required String question,
  }) async {
    try {
      await _supabase.from('qa_entries').insert({
        'vehicle_id': vehicleId,
        'asker_id': askerId,
        'question': question,
        'is_public': true,
      });
    } on PostgrestException catch (e) {
      throw Exception('Failed to ask question: ${e.message}');
    }
  }

  /// Answer a question (seller only)
  Future<void> answerQuestion({
    required String qaId,
    required String answer,
  }) async {
    try {
      await _supabase.from('qa_entries').update({
        'answer': answer,
        'answered_at': DateTime.now().toIso8601String(),
      }).eq('id', qaId);
    } on PostgrestException catch (e) {
      throw Exception('Failed to answer question: ${e.message}');
    }
  }
}
```


STEP 3: Update Browse Module DI
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/browse/browse_module.dart

Add imports:
```dart
import '../../app/core/config/supabase_config.dart';
import 'data/datasources/auction_supabase_datasource.dart';
import 'data/datasources/bid_supabase_datasource.dart';
import 'data/datasources/qa_supabase_datasource.dart';
```

Update useMockData:
```dart
static const bool useMockData = false;
```

Add Supabase datasource creators:
```dart
AuctionSupabaseDataSource _createAuctionSupabaseDataSource() {
  return AuctionSupabaseDataSource(SupabaseConfig.client);
}

BidSupabaseDataSource _createBidSupabaseDataSource() {
  return BidSupabaseDataSource(SupabaseConfig.client);
}

QASupabaseDataSource _createQASupabaseDataSource() {
  return QASupabaseDataSource(SupabaseConfig.client);
}
```

Update repository creation to use Supabase datasources when useMockData = false.


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ AFTER BROWSE MODULE: IMPLEMENT LISTS MODULE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

STEP 4: Create Listing Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/lists/data/datasources/listing_supabase_datasource.dart

Key operations:
- getSellerListings(sellerId, status) â†’ Query vehicles table
- createDraft(sellerId, vehicleData) â†’ Insert into vehicles
- updateListing(vehicleId, updates) â†’ Update vehicles
- uploadVehiclePhoto(vehicleId, file, category) â†’ Upload to vehicle-photos bucket
- submitForApproval(vehicleId) â†’ Update status to 'pending'
- deleteListing(vehicleId) â†’ Delete from vehicles (if draft/cancelled)


STEP 5: Create Seller Transaction Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/lists/data/datasources/seller_transaction_supabase_datasource.dart

Key operations:
- getSellerTransactions(sellerId) â†’ Query transactions table
- submitSellerForm(transactionId, formData) â†’ Insert into transaction_forms
- confirmSellerForm(transactionId) â†’ Update transactions.seller_confirmed
- updateDeliveryStatus(transactionId, status) â†’ Update delivery_status


STEP 6: Create Chat Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/lists/data/datasources/chat_supabase_datasource.dart

Key operations:
- getMessages(transactionId) â†’ Query chat_messages
- sendMessage(transactionId, senderId, message) â†’ Insert into chat_messages
- markAsRead(transactionId, userId) â†’ Update is_read
- streamMessages(transactionId) â†’ Real-time subscription


STEP 7: Create Timeline Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/lists/data/datasources/timeline_supabase_datasource.dart

Key operations:
- getTimeline(transactionId) â†’ Query transaction_timeline
- addTimelineEvent(transactionId, eventData) â†’ Insert into transaction_timeline


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ AFTER LISTS MODULE: IMPLEMENT BIDS MODULE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

STEP 8: Create Buyer Transaction Datasource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/modules/bids/data/datasources/buyer_transaction_supabase_datasource.dart

Key operations:
- getBuyerTransactions(buyerId) â†’ Query transactions table
- submitBuyerForm(transactionId, formData) â†’ Insert into transaction_forms
- confirmBuyerForm(transactionId) â†’ Update transactions.buyer_confirmed
- getUserBids(userId) â†’ Query bids table


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ QUICK IMPLEMENTATION TIPS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. USE EXISTING PATTERNS
   â†’ auction_supabase_datasource.dart is your reference
   â†’ profile_supabase_datasource.dart for file uploads
   â†’ All follow same error handling pattern

2. COLUMN NAME MAPPING
   â†’ Database uses snake_case (current_bid, main_image_url)
   â†’ Models use camelCase (currentBid, carImageUrl)
   â†’ Map in fromJson/toJson methods

3. REAL-TIME CHAT
   ```dart
   final stream = _supabase
       .from('chat_messages')
       .stream(primaryKey: ['id'])
       .eq('transaction_id', transactionId);
   ```

4. FILE UPLOADS
   ```dart
   final filepath = '$vehicleId/$category/${timestamp}_$filename';
   await _supabase.storage.from('vehicle-photos').upload(filepath, file);
   final url = _supabase.storage.from('vehicle-photos').getPublicUrl(filepath);
   ```

5. JOINS
   ```dart
   .select('*, user_profiles(username, profile_photo_url)')
   .select('*, vehicles!inner(brand, model, year)')
   ```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“š REFERENCE FILES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Guides:
  â€¢ BACKEND_INTEGRATION_GUIDE.txt - Complete implementation guide
  â€¢ IMPLEMENTATION_STATUS.txt - Progress tracker
  â€¢ NEXT_STEPS.txt - This file

Implemented Examples:
  â€¢ lib/modules/profile/data/datasources/profile_supabase_datasource.dart
  â€¢ lib/modules/browse/data/datasources/auction_supabase_datasource.dart
  â€¢ lib/modules/auth/data/datasources/auth_remote_datasource.dart

Database:
  â€¢ supabase_schema.sql
  â€¢ supabase_rls_policies.sql
  â€¢ supabase_storage_setup.sql

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… TESTING CHECKLIST (After Each Module)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â–¡ Run flutter pub get
â–¡ Set useMockData = false in module
â–¡ Run app and navigate to module
â–¡ Check Supabase Dashboard > Table Editor for data
â–¡ Verify CRUD operations work
â–¡ Check Supabase Logs for errors
â–¡ Test on both Android and Web (if applicable)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Start with Browse module (Steps 1-3), then Lists (Steps 4-7), then Bids (Step 8).
Follow the patterns from completed modules. Database is ready, just connect it!
